<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Keeplinks POC</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    input, textarea, button { width: 100%; margin: 10px 0; padding: 10px; }
    #chat { background: #f9f9f9; height: 200px; overflow-y: auto; padding: 10px; white-space: pre-wrap; }
  </style>
</head>
<body>

<h2>Code WebRTC Chat</h2>

<input id="roomCode" placeholder="Enter Room Code (e.g. room123)" />
<button onclick="joinRoom()">Join Room</button>

<div id="connectionStatus">Status: Not Connected</div>

<input id="message" placeholder="Type a message..." />
<button onclick="sendMessage()">Send</button>

<div id="chat">Chat log:</div>

<script>
  let socket, pc, channel;
  const chat = document.getElementById("chat");

  const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  function log(text) {
    chat.textContent += text + "\n";
    chat.scrollTop = chat.scrollHeight;
  }

  function joinRoom() {
    const room = document.getElementById("roomCode").value;
    if (!room) return alert("Enter a room code");

    socket = new WebSocket("wss://087d3667-bff0-4ec7-8fda-273b3bfb4c17-00-35xnc7h534r9p.spock.replit.dev:3000");

    socket.onopen = () => {
      socket.send(JSON.stringify({ type: "join", room }));
      document.getElementById("connectionStatus").textContent = "Status: Joined room, waiting...";
    };

    socket.onmessage = async (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === "ready") {
        startPeer(true);
      } else if (msg.type === "signal") {
        if (!pc) await startPeer(false);
        const signal = msg.data;

        if (signal.sdp) {
          await pc.setRemoteDescription(new RTCSessionDescription(signal));
          if (signal.type === "offer") {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: "signal", data: pc.localDescription }));
          }
        } else if (signal.candidate) {
          await pc.addIceCandidate(new RTCIceCandidate(signal));
        }
      }
    };
  }

  async function startPeer(isInitiator) {
    pc = new RTCPeerConnection(servers);

    pc.onicecandidate = e => {
      if (e.candidate) {
        socket.send(JSON.stringify({ type: "signal", data: e.candidate }));
      }
    };

    pc.ondatachannel = e => {
      channel = e.channel;
      channel.onmessage = e => log("Peer: " + e.data);
      channel.onopen = () => document.getElementById("connectionStatus").textContent = "Status: Connected ✅";
    };

    if (isInitiator) {
      channel = pc.createDataChannel("chat");
      channel.onmessage = e => log("Peer: " + e.data);
      channel.onopen = () => document.getElementById("connectionStatus").textContent = "Status: Connected ✅";

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.send(JSON.stringify({ type: "signal", data: offer }));
    }
  }

  function sendMessage() {
    const msg = document.getElementById("message").value;
    if (channel && channel.readyState === "open") {
      channel.send(msg);
      log("You: " + msg);
      document.getElementById("message").value = "";
    } else {
      alert("Connection not ready yet.");
    }
  }
</script>

</body>
</html>
