<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Chat (Cross-Platform)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    input, textarea, button { width: 100%; margin: 10px 0; padding: 10px; }
    #chat { background: #f9f9f9; height: 200px; overflow-y: auto; padding: 10px; white-space: pre-wrap; }
  </style>
</head>
<body>

<h2>üîÅ WebRTC Chat (Web ‚Üî Flutter)</h2>

<input id="roomCode" placeholder="Enter Room Code" />
<button onclick="joinRoom()">Join Room</button>

<div id="connectionStatus">Status: Not Connected</div>

<input id="message" placeholder="Message" />
<button onclick="sendMessage()">Send</button>

<div id="chat">Chat log:</div>

<script>
  let socket, pc, channel;
  let isInitiator = false;
  const chat = document.getElementById("chat");

  const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  function log(text) {
    chat.textContent += text + "\\n";
    chat.scrollTop = chat.scrollHeight;
    console.log("[log]", text);
  }

  function joinRoom() {
    const room = document.getElementById("roomCode").value;
    if (!room) return alert("Enter a room code");

    socket = new WebSocket("wss://webrtc-node-0s89.onrender.com");

    socket.onopen = () => {
      socket.send(JSON.stringify({ type: "join", room }));
      document.getElementById("connectionStatus").textContent = "Status: Joined room, waiting...";
    };

    socket.onmessage = async (event) => {
      const msg = JSON.parse(event.data);
      console.log("[Socket Message]", msg);

      if (msg.type === "ready") {
        isInitiator = msg.initiator; // üëà read initiator role from server
        console.log("Assigned initiator:", isInitiator);
        await startPeer();
        if (isInitiator) {
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.send(JSON.stringify({ type: "signal", data: offer }));
          console.log("üì§ Sent offer");
        }
      } else if (msg.type === "signal") {
        const signal = msg.data;
        if (!pc) await startPeer();

        if (signal.sdp) {
          await pc.setRemoteDescription(new RTCSessionDescription(signal));
          console.log("üì• Set Remote Description:", signal.type);

          if (signal.type === "offer") {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: "signal", data: pc.localDescription }));
            console.log("üì§ Sent answer");
          }
        } else if (signal.candidate) {
          await pc.addIceCandidate(new RTCIceCandidate(signal));
          console.log("‚ûï Added ICE Candidate");
        }
      }
    };
  }

  async function startPeer() {
    if (pc) return;

    pc = new RTCPeerConnection(servers);

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        socket.send(JSON.stringify({ type: "signal", data: e.candidate }));
      }
    };

    pc.ondatachannel = (e) => {
      channel = e.channel;
      setupChannel();
    };
  }

  function setupChannel() {
    channel.onopen = () => {
      document.getElementById("connectionStatus").textContent = "Status: Connected ‚úÖ";
      log("‚úÖ Data Channel Open");
    };
    channel.onmessage = (e) => {
      log("Peer: " + e.data);
    };
  }

  function sendMessage() {
    const msg = document.getElementById("message").value;
    if (channel && channel.readyState === "open") {
      channel.send(msg);
      log("You: " + msg);
      document.getElementById("message").value = "";
    } else {
      alert("Connection not ready yet.");
    }
  }
</script>

</body>
</html>
